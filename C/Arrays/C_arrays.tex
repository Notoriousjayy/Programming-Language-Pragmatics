{\bf Arrays in C}
\vskip 1mm
\hrule

\vskip 1cm
{\bf Declaration of Arrays}

$$\hbox{\tt type name[size];}$$

\filbreak
\vskip 1cm
{\bf Accessing the Elements of an Array}

$$\hbox{\bf /* Set each element of the array to -1 */}$$
$$\vbox{\+\tt int i, \cleartabs& \tt marks[10]; \cr
	\+\tt for(i = 0; i < 10; i++) $\{$\cr
	\+&\tt marks[i] = -1;\cr
	\+$\}$\cr}$$

\filbreak
\vskip 1cm
{\bf Calculating th Address of Array Elements}

$$\hbox{\bf /* Address of data element*/}$$
$$\hbox{\tt A[k] = BA(A) + w(k - lower$\_$bound);}$$

where {\tt A} is the array, {\tt k} is the index of the element that we want to calculate. {\tt BA} is the {\bf base address} of the array {\tt A}, and {\tt w} is the size of one element in memory.

\vskip 1cm
{\bf Example}
\vskip 1mm
Given an array {\tt int marks[] = $\{$ 99, 67, 78, 56, 88, 90, 34, 85 $\}$}, calcuate the address of
\vskip 1mm
{\tt marks[4]} if the {\tt base address = 1000}.

\vskip 0.5cm
$$\eqalign{\tt marks[4] &= 1000 + 2(4 - 0) \cr
			&= 1000 + 2(4)\cr
			&= 1008\cr}$$

\filbreak
\vskip 1cm
{\bf Calculating the Length of an Array}

$$\hbox{\tt Length = upper$\_$bound - lower$\_$bound + 1}$$

where {\tt upper$\_$bound} is the index of the last element and {\tt lower$\_$bound} is the index of the first element in the array.

\filbreak
\vskip 1cm
{\bf Initializing Arrays during Declaration}

$$\hbox{\tt type array$\_$name[size] = $\{$ list of values $\}$;}$$

In C we write

$$\hbox{\tt int marks[5] = $\{$ 90, 82, 78, 95, 88 $\}$;}$$

where {\tt list of values} is a comma separated list.

\filbreak
\vskip 1cm
{\bf Inputting Values from the Keyboard}

$$\vbox{\+\tt int i, \cleartabs& \tt marks[10]; \cr
	\+\tt for( i = 0; i < 10; i++ ) $\{$ \cr
	\+\tt scanf("$\%$d", $\&$marks[i]);\cr
	\+$\}$\cr}$$

\filbreak
\vskip 1cm
{\bf Assigning Values to Individual Elements}
$$\hbox{\bf /* Code to copy an array at the individual element level */}$$
$$\vbox{\+\tt int i, \cleartabs& \tt array1[10], array2[10]; \cr
	\+\tt array1[10] = $\{$ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 $\}$;\cr
	\+\tt for( i = 0; i < 10; i++ ) $\{$ \cr
	\+&\tt array2[i] = array1[i];\cr
	\+\tt $\}$\cr}$$

$$\hbox{\bf /* Code for filling an array with even numbers */}$$
$$\vbox{\+\tt int i, \cleartabs& \tt array[10]; \cr
	\+\tt for( i = 0; i < 10; i++ ) $\{$ \cr
	\+&\tt array[i] = i * 2;\cr
	\+\tt $\}$\cr}$$

\filbreak
\vskip 1cm
{\bf Passing Arrays To Functions}

\vskip 1cm
\centerline{\bf Passing Data Values}

$$\hbox{\bf /* Passes value of individual array element to a function*/}$$
$$\vbox{\+\tt int \cleartabs& \tt main() $\{$\cr
	\+&\tt int arr[5] = $\{$ 1, 2, 3, 4, 5 $\}$;\cr
	\+&\tt fun(arr[3]);\cr
	\+$\}$\cr}$$

$$\hbox{\bf /* Called function */}$$
$$\vbox{\+\tt void \cleartabs& \tt func(int num) $\{$\cr
	\+&\tt printf("$\%$d", num);\cr
	\+\tt $\}$\cr}$$

\vskip 1cm
\centerline{\bf Passing Addresses}

$$\hbox{\bf /* Passes address of individual array element to a function*/}$$
$$\vbox{\+\tt int \cleartabs& \tt main() $\{$\cr
	\+&\tt int arr[5] = $\{$ 1, 2, 3, 4, 5 $\}$;\cr
	\+&\tt fun($\&$arr[3]);\cr
	\+\tt $\}$\cr}$$

$$\hbox{\bf /* Called function */}$$
$$\vbox{\+\tt void \cleartabs& \tt func(int num) $\{$\cr
	\+&\tt printf("$\%$d", *num);\cr
	\+\tt $\}$\cr}$$

\vskip 1cm
\centerline{\bf Passing the Entire Array}

$$\hbox{\bf /* Passes entire array to a function */}$$
$$\vbox{\+\tt int \cleartabs& \tt main() $\{$\cr
	\+&\tt int arr[5] = $\{$ 1, 2, 3, 4, 5 $\}$;\cr
	\+&\tt fun(arr);\cr
	\+\tt $\}$\cr}$$
$$\hbox{\bf /* Called function */}$$
$$\vbox{\+\tt void \cleartabs& \tt func(int arr[5]) $\{$\cr
	\+&\tt int i; \cr
	\+&\tt for(i &\tt = 0; i < 5; i++) $\{$\cr
	\+&&\tt printf("$\%$d", arr[i]);\cr
	\+\tt $\}$\cr}$$

\filbreak
a function that accepts an array can declare the formal parameter in either of the two following ways

$$\hbox{{\tt func(int arr[]);} or}$$
$$\hbox{\tt func(int *arr);}$$

a function that accepts an array as a parameter, the declaration should look like this

$$\hbox{{\tt func(int arr[], int n);} or}$$
$$\hbox{\tt func(int *arr, int n);}$$

\filbreak
\vskip 1cm
{\bf Declaring Two-dimensional Arrays}

$$\hbox{\tt data$\_$type array$\_$name[row$\_$size][column$\_$size];}$$

\filbreak
\vskip 1cm
{\bf Calculating the Address of a 2-Dimensional Array}

$$\hbox{\bf /* Column major order */}$$
$$\hbox{\tt Address(A[I][J]) = Base$\_$Address + w$\{$ M (J - 1) + (I - 1) $\}$}$$

$$\hbox{\bf /* Row major order */}$$
$$\hbox{\tt Address(A[I][J]) = Base$\_$Address + w$\{$ N (I - 1) + (J - 1) $\}$}$$

where {\tt w} is the number of bytes required to store one element, {\tt N} is the number of columns, {\tt M} is the number of rows, and {\tt I} and {\tt J} are subscripts of the array element.

\filbreak
\vskip 1cm
{\bf Example}
\vskip 1mm
Consider a $20 \times 5$ two-dimensional array {\tt marks} which has its {\tt base address = 1000} and size of an element = 2. Now compute the address of the element, {\tt marks[18][4]} assuming that the elements are stored in row major order.


$$\eqalign{\tt Address(A[I][J]) &= Base\_Address + w\{ N (I - 1) + (J - 1) \}\cr
		\tt Address(marks[18][4]) &= 1000 + 2 \{ 5(18 - 1) + (4 - 1) \}\cr
					\tt &= 1000 + 2 \{ 5(17) + (4 - 1) \}\cr
					\tt &= 1000 + 2 \{ 5(17) + (3) \}\cr
					\tt &= 1000 + 2(88) \}\cr
					\tt &= 1000 + 176\cr
					\tt &= 1176\cr}$$

\filbreak
\vskip 1cm
{\bf Passing Two-Dimensional Arrays To Functions}

\vskip 1cm
\centerline{\bf Passing a Row}

$$\hbox{\bf /* Passing a row of a 2D array to a function*/}$$
$$\vbox{\+\tt int \cleartabs& main() $\{$\cr
	\+&\tt int arr[2][3] = $\bigl(\{$ 1, 2, 3 $\}$, $\{$4, 5, 6 $\}\bigr)$;\cr
	\+&\tt func(arr[1]);\cr
	\+$\}$\cr}$$

$$\hbox{\bf /* Called Function*/}$$
$$\vbox{\+\tt void \cleartabs& func(int arr[]) $\{$ \cr
	\+&\tt int i;\cr
	\+&\tt for&\tt(i = 0; i < 3; i++) \cr
	\+&&\tt printf("$\%$d" arr[i] * 10);\cr
	\+ $\}$\cr}$$

\filbreak
\vskip 1cm
{\bf Pointers and Three-Dimensional Arrays}

$$\hbox{\bf /* Declaring a pointer to aone-dimmensional array*/}$$
$$\vbox{\+\tt int arr[] = $\{$ 1, 2, 3, 4, 5 $\}$;\cr
	\+\tt int *parr;\cr
	\+\tt parr = arr;\cr}$$

$$\hbox{\bf /* Declaring a pointer to a two-dimmensional array*/}$$
$$\vbox{\+\tt int arr[2][2] = $\{\{$ 1, 2 $\}$, $\{$ 3, 4 $\}\}$;\cr
	\+\tt int (*parr)[2];\cr
	\+\tt parr = arr;\cr}$$

$$\hbox{\bf /* Declaring a pointer to a three-dimmensional array*/}$$
$$\vbox{\+\tt int arr[2][2][2] = $\{$ 1, 2, 3, 4, 5, 6, 7, 8 $\}$;\cr
	\+\tt int (*parr)[2][2];\cr
	\+\tt parr = arr;\cr}$$

we can access an element of a three-dimensional array by writing

$$\hbox{\tt arr[i][j][k] = *(*(*(arr + i) + j + k)}$$

\filbreak
\vskip 1cm
{\bf Points To Remember}

\vskip 3mm
$\bullet$ An array is a collection of elements of the same data type.

\vskip 3mm
$\bullet$ The elements of an array are stored in consecutive memory locations and are referenced by an index (also known as the subscript).

\vskip 3mm
$\bullet$ The index specifies an offset from the beginning of the array to the element being referenced.

\vskip 3mm
$\bullet$ Declaring an array means specifying three parameters: data type, name, and its size.

\vskip 3mm
$\bullet$ The length of an array is given by the number of elements stored in it.

\vskip 3mm
$\bullet$ There is no single function that can operate on all the elements of an array. To access all the elements, we must use a loop.

\vskip 3mm
$\bullet$ The name of an array is a symbolic reference to the address of the first byte of the array. Therefore, whenever we use the array name, we are actually referring to the first byte of that array.

\vskip 3mm
$\bullet$ C considers a two-dimensional array as an array of one-dimensional arrays.

\vskip 3mm
$\bullet$ A two-dimensional array is specified using two subscripts where the first subscript denotes the row and the second subscript denotes the column of the array.

\vskip 3mm
$\bullet$ Using two-dimensional arrays, we can perform the different operations on matrices: transpose, addition, subtraction, multiplication.

\vskip 3mm
$\bullet$ A multi-dimensional array is an array of arrays. Like we have one index in a one-dimensional array, two indices in a two-dimensional array, in the same way we have n indices in an n-dimensional or multi-dimensional array. Conversely, an n-dimensional array is specified using n indices.

\vskip 3mm
$\bullet$ Multi-dimensional arrays can be stored in either row major order or column major order.

\vskip 3mm
$\bullet$ Sparse matrix is a matrix that has large number of elements with a zero value.

\vskip 3mm
$\bullet$ There are two types of sparse matrices. In the first type, all the elements above the main diagonal have a zero value. This type of sparse matrix is called a lower-triangular matrix. In the second type, all the elements below the main diagonal have a zero value. This type of sparse matrix is called an upper-triangular matrix.

\vskip 3mm
$\bullet$ There is another variant of a sparse matrix, in which elements with a non-zero value can appear only on the diagonal or immediately above or below the diagonal. This type of sparse matrix is called a tridiagonal matrix.
%$$\vbox{\+\bf \cleartabs& \cr
%	\+\cr
%	\+\cr
%	\+\cr}$$

\filbreak
\vfill\eject
\bye
