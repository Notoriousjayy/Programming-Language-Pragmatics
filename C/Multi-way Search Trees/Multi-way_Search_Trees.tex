{\bf Multi-way Search Trees}
\vskip 1mm
\hrule

\vskip 3mm
{\bf Introduction}

\vskip 1mm
Every node in a binary search tree contains one value and two pointers, {\bf left} and {\bf right}, which point to the node's left and right sub-trees, respectively. The same concept is us in an {\bf M-way} search tree which has $M-1$ values per node and $M$ sub-trees. In such a tree $M$ is called the degree of the tree. Every internal node of an M-way search tree consists of pointers to $M$ sub-trees and contains $M-1$ keys, where $M>2$.

$$\vbox{\settabs 10 \columns
	\+$P_0$&$K_0$&$P_1$&$K_1$&$P_2$&$K_2$&$\cdots$&$P_{n-1}$&$K_{n-1}$&$P_n$\cr
	\+\cr}$$

All the key values are stored in ascending order. That is, $K_1<K_{i+1}$ for $0\leq i \leq n-2$

\vskip 1mm
In an M-way search tre, it is not compulsory that every node has exactly $M-1$ values and $M$ sub-trees. Rather, the node can have anywhere from $1$ to $M-1$ values, and the number of sub-trees can bary from $0$ (for a leaf node) to $i+1$, where $i$ is the number of key values in the node. $M$ is thus a fixed upper limit that defines how many key values can be stored in the node.

\vskip 1mm
Basic properties of M-way search tree.

\vskip 2mm
\qquad$\bullet$ Note that the key values in the sub-tree pointed by $P_0$ are less than the key value $K_0$. Similarly, all the key values in the sub-tree pointed by $P_1$ are less than $K_1$, so on and so forth. Thus, the generalized rule is that all the key values in the sub-tree pointed by $P_i$ are less than $K_i$, where $0\leq i \leq n-1$

\vskip 3mm
\qquad$\bullet$ Note that the key values in the sub-tree pointed by $P_1$ are greater than the key value $K_0$. Similarly, all the key values in the sub-tree pointed by $P_2$ are greater than $K_1$, so on and so forth. Thus, the generalized rule is that all the key values in the sub-tree pointed by $P_i$ are greater than $K_{i-1}$, where $0\leq i \leq n-1$.

\vskip 1mm
In an M-way search tree, every sub-tree is also an M-way search tree and follows the same rules.

\filbreak
\vskip 1cm
{\bf B Trees}

\vskip 1mm
A B-tree is a specialized M-way tree. A B-tree of order $m$ can have a maximum of $m-1$ keys and $m$ pointers to its sub-trees. A B-tree may contain a large number of key values and pointers to sub-trees. Storing a large number of keys in a single node keeps the height of the tree relatively small.

A B-tree is designed to store data and allows search, insertion, and deletion operations to be performed in logarithmi amortized time. A B-tree of order $m$ (the maximum number of children that each node can have) is a tree with all the properties of an M-way search tree. In addition it has the following properties:

\vskip 1mm
\qquad{\bf(1)} Every node in the B-tree has at most (maximum) $m$ children.

\vskip 3mm
\qquad{\bf(2)} Every node in the B-tree except the root node and leaf node has at least (minimum) ${m\over 2}$ children. This condition helps to keep the tree bushy so that the path from the root node to the leaf is very short, even in a tree that stores a lot of data.

\vskip 3mm
\qquad{\bf(3)} The root node has at least two children if it is not a terminal (leaf) node.

\vskip 3mm
\qquad{\bf(4)} All leaf nodes are at the same level.

\vskip 1mm
An internal node in the B-tree can have $n$ number of children, where $0\leq n \leq m$ It is not necessary that every node has the same number of children, but the only restriction is that the node should have at least ${m\over 2}$ children. While performing insertion and deletion operations in a B-tree, the number of child nodes may change. So, in order to maintain a minimum number of children, the internal nodes may be joined or split.

\filbreak
\vskip 1cm
{\bf Searching for an Element in a B-Tree}

\vskip 1mm
Searching for an element in a B-tree is similar to that in binary search trees. Since the running time of the search operation depends upon the height of the tree, the algorithm to search for an element in a B-tree takes $O(\log_t n)$ time to execute.

\filbreak
\vskip 1cm
{\bf Inserting a New Element in a B-Tree}

\vskip 1mm
In a B-tree, all insertions are done at the leaf node level. A new value is inserted in the B-tree using the algorithm below.

\vskip 1mm
1. Search the B-tree to find the leaf node where the new key value should be inserted.

\vskip 3mm
2. If the leaf node is not full, that is, it contains less than $m-1$ key values, then insert the new element in the node keeping the node's elements ordered.

\vskip 3mm
3. If the leaf node is full, that is, the leaf node already contains $m-1$ key values, then

\vskip 1mm
\qquad{\bf(a)} insert the new value in order into the existing set of keys,

\vskip 2mm
\qquad{\bf(b)} split the node at its median into two nodes (note that the split nodes are half full), and 

\vskip 2mm
\qquad{\bf(c)} push the median element up its parent's node. If the parent's node is already full, then split the parent node by following the same steps.

\filbreak
\vskip 1cm
{\bf Deleting an Element from a B-Tree}

\vskip 1mm
Like insertion, deletion is also done from the leaf nodes. There are two cases of deletion. In the first case, a leaf node has to be deleted. In the second case, an internal node has to be deleted. Let us first see the steps involved in deleting a leaf node.

\vskip 1mm
1. Locate the leaf node which has to be deleted.

\vskip 3mm
2. If the leaf node contains more than the minimum number of key values (more than ${m\over 2}$ elements), then dekete the value.

\vskip 3mm
3. Else if the leaf node does not contain ${m\over 2}$ elements, then fill the node by taking an element either from the left or from the right sibling.

\vskip 2mm
\qquad{\bf(a)} If the left sibling has more than the minimum number of key values, push its largest key into its parent's node where the key is deleted.

\vskip 2mm
\qquad{\bf(b)} Else, if the right sibling has more than the minimum number of key values, push its node o the leaf node where the key is deleted.

\vskip 3mm
4. Else, if both left and right siblings contain only the minimum number of elements, then create a new leaf node by combining the two leaf nodes and the intervening element of the parent node (ensuring that the number of elements does not exceed the maximum number of elements a node can have, that is $m$). If pulling the intervening element from the parent node leaves it with less than the minimum number of keys in the node, then propagate the process upwards, thereby reducing the height of the B-tree.

\vskip 1mm
To delete an internal node, promote the successor or predecessor of the key to be deleted to occupy the position of the deleted key. this predecessor or successor will always be in the leaf node. So the processing will be done as if a value from the leaf node has been deleted.

\filbreak
\vskip 1cm
{\bf B+ Trees}

\vskip 1mm
A B+ Tree is a variant of a B-tree which stores data in a way that allows for efficient insertion, retrieval, and removal of records, each of which is identified by a {\bf key}. While a B-tree can store both keys and records in its interior nodes, a B+ tree, in contrast, stores all the records at the leaf level of the tree; only keys are stored in the interior nodes.

\vskip 1mm
The leaf nodes of a B+ tree are often linked to one another in a linked list. Typically, B+ trees are used to stored large amounts of data that cannot be stored in the main memory. With B+ trees, the secondary storage (magnetic disk) is used to store the leaf nodes of trees and the internal nodes of trees are stored in the main memory.

\vskip 1mm
B+ trees store data only in the leaf nodes. All other nodes (internal nodes) are {\bf index nodes} or {i-nodes} and store index values. This allows us to traverse the tree from the root down to the leaf node that stores the desired data item.

\vskip 1mm Many database systems are implemented using B+ tree structure because of its simplicity. Since all the data appear in the leaf nodes and are ordered, the tree is always balanced and makes searching for data efficient.

\vskip 1mm
A B+ tree can be thought of as a multi-level index in which the leaves make up a dense index and the non-leaf nodes make up a sparse index. The advantage of B+ trees can be given as:

\vskip 1mm
{\bf(1)} Records can be fetched in equal number of disk accesses

\vskip 3mm
{\bf(2)} It can be used to perform a wide range of queries easily as leaves are linked to nodes at the upper level

\vskip 3mm
{\bf(3)} Height of the tree is less balanced

\vskip 3mm
{\bf(4)} Supports both random and sequential access to records

\vskip 3mm
{\bf(5)} Keys are used for indexing

\vskip 3mm
{\bf Comparison Between B-trees and B+ Trees}

\vskip 1mm
{\bf B-trees}
\vskip 1mm
\qquad{\bf(1)} Seach keys are not repeated

\vskip 3mm
\qquad{\bf(2)} Data is stored in ineternal or leaf nodes

\vskip 3mm
\qquad{\bf(3)}  Searching takes more time as data may be found in a leaf or non-leaf node

\vskip 3mm
\qquad{\bf(4)} Deletion of non-leaf nodes is very complicated

\vskip 3mm
\qquad{\bf(5)} Leaf nodes cannot be stored using linked lists

\vskip 3mm
\qquad{\bf(6)} The strucutre and operations are complicated

\vskip 3mm
{\bf B+ Tree}
\vskip 1mm
\qquad{\bf(1)} Stores redundant search key

\vskip 3mm
\qquad{\bf(2)} Data is stored only in leaf nodes

\vskip 3mm
\qquad{\bf(3)} Searching data is very easy as the data can be found in leaf nodes only

\vskip 3mm
\qquad{\bf(4)} Deletion is very simply because data will be in the leaf node

\vskip 3mm
\qquad{\bf(5)} Leaf node data are ordered using sequential linked lists

\vskip 3mm
\qquad{\bf(6)} The structure and operations are simple

\filbreak
\vskip 1cm
{\bf Inserting a New Element in a B+ Tree}

\vskip 1mm
A new element is simply added in the leaf node if there is space for it. If the data node in the tree where insertion has to be done is full, then that node is split into two nodes. This call for adding a new index value in the parent index node so that future queries can arbitrate between the two nodes.

\vskip 1mm
Adding the new index value in the parent node may cause it, in turn, to split. In factm all the nodes on the path from a leaf to the root may split when a value is added to a leaf node. If the root node splits, a new leaf node is created and the tree grows by one level. Steps to insert a node in a B+ Tree

\vskip 1mm
{\bf Step 1:} Insert the new node as the leaf node.

\vskip 3mm
{\bf Step 2:} If the leaf node overflows, split the node and copy the middle element to next index node.

\vskip 3mm
{\bf Step 3:} If the index node overflows, split that node and move the middle element to next index page.

\filbreak
\vskip 1cm
{\bf Deleting an Element from a B+ Tree}

\vskip 1mm
As in B-trees, deletion is always done from a leaf node. If deleting a data element leaves that node empty, then the neighboring nodes are examined and merged with the {\bf underfull} node.

\vskip 1mm
This process calls for the deletiong of an index value from the parent node which, in turn, may cause it to become empty. Similar to the insertion proces, deletiong may cause a merge-delete wave to run from a leaf node all the way up to the root. This leads to shrinking of the tree by one level. step to delete a node from a B+ Tree

\vskip 1mm
{\bf Step 1:} Delete the key and data from the leaves.

\vskip 3mm
{\bf Step 2:} If the leaf node underflows, merge that node wit the sibling and delete the key in between them.

\vskip 3mm
{\bf Step 3:} If the index node underflows, merge that node with the sibling and move down the key in between them.

\filbreak
\vskip 1cm
{\bf 2-3 Trees}

\vskip 1mm
In a 2-3 tree, each interior node has either two or three children:

\vskip 1mm
\qquad$\bullet$ Nodes with two children are called 2-nodes. The 2-nodes have one data value and two children

\vskip 3mm
\qquad$\bullet$ Nodes with three children are called 3-nodes. The 3-nodes have two data values and three children (left child, middle child, and a right child)

\vskip 3mm
This means that a 2-3 tree is not a binary tree. In this tree, all the leaf nodes are at the same level (bottom level).

\vskip 1cm
{\bf Searching for an Element in a 2-3 Tree}

\vskip 1mm
The search operation is used to determine whether a data value $x$ is present in a 2-3 tree $T$. The process of searching a value in a 2-3 tree is very similar to searching a binary search tree.

\vskip 1mm
The search for a data value $x$ starts at the root. If $k_1$ and $k_2$ are two values stored in the root node, then

\vskip 1mm
\qquad$\bullet$ if $x<k_1$, move to the left child

\vskip 3mm
\qquad$\bullet$ if $x\geq k_1$ and the node has only two children, move to the right child.

\vskip 3mm
\qquad$\bullet$ if $x\geq k_1$ and the node has three children, then move to the middle child if $x<k_2$ else to the right child if $x\geq k_2$

\vskip 1mm
At the end of this process, the node with data value $x$ is reached if and only if $x$ is at this leaf.

\filbreak
\vskip 1cm
{\bf Inserting a New Element in a 2-3 Tree}

\vskip 1mm
To insert a new value in the 2-3 tree, an apppropriate position of the value is located in one of the leaf nodes. If after insertion of the value, the properties of the 2-3 tree do not get violated then insertion is over. Otherwise, if any property is violated then the violating node must be split.

\vskip 3mm
{\bf Splitting a node}

\vskip 1mm
A node is split when it has three value data values and four children.

\filbreak
\vskip 1cm
{\bf Deleting an Element from a 2-3 Tree}

\vskip 1mm
In the deletion process, a specified data value is deleted from the 2-3 tree. If deleting a value from a node violates the property of a tree, that is, if a node is left with less than one data value then two nodes must be merged together to preserve the general properties of a 2-3 tree.

\vskip 1mm
In insertion,the new value had to be added in any of the leaf nodes but in deletion it is not necessary that the value has to be deleted from a leaf node. The value can be deleted from any of the nodes. To delete a value $x$, it is replaced by its in-order successor and then removed. If a node becomes empty after deleting a value, it is then merged with another node to restore the property of the tree.

\filbreak
\vskip 1cm
{\bf Trie}
A trie is an ordered tree data structure. Trie stores keys that usualy strings. It is basically a $k$-ary position tree.

\vskip 1mm
In contrast to binary search trees, nodes in a trie do not store the keys associated with them. Rather, a node's position in the tree represents the key associated with that node. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string.

\vskip 3mm
{\bf Advantages Relative to Binary Search Tree}

\vskip 1mm
When compared with a binary search tree, the trie data structure has the following advantages:

\vskip 3mm
{\bf Faster Search}
\vskip 1mm
Searching for keys is faster, as searching a key of length $m$ takes $O(m)$ time in the worst case. On the other hand, a binary search tree performs $O(\log n)$ comparisons of keys, where $n$ is the number of nodes in the tree. Since search time depends on the height of the tree which is logarithmic in the number of keys (if the tree is balanced), the worst case may take $O(m \log n)$ time. In addition to this $m$ approaches $\log(n)$ in the worst case. Hence, a trie data structure provides a faster search mechanism.

\vskip 3mm
{\bf Less space}
\vskip 1mm
Trie occupies less space, especially when it contains a large number of short strings. Since keys are not stored explicitly and nodes are shared between the keys with common initial subsequences, a trie calls for less space as compared to a binary search tree.

\vskip 3mm
{\bf Longest Prefix-Matching}

\vskip 1mm
Trie facilitates the longest prefix-matching which enables us to find the key sharing the longest possible prefix of all unique characters. Since trie provides more advantages, it can be though of as a good replacement for binary search trees.

\vskip 3mm
{\bf Advantages Relative to hash Table}

\vskip 1mm
Trie can also be used to replace a {\bf hash table} as it provides the following advantages:

\vskip 1mm
\qquad$\bullet$ Searching for data in a trie is faster in the worst case, $O(m)$ time, compared to an imperfect hash table, which may have numerous key collisions. Trie is free from collision of keys problem.

\vskip 3mm
\qquad$\bullet$ Unlike a hash tablem there is no need to choose a hash function or to change it when more keys are added to a trie.

\vskip 3mm
\qquad$\bullet$ A trie can sort the keys using a predetermined alphabetical ordering.

\vskip 3mm
{\bf Disadvantages}

\vskip 1mm
The disadvantages of having a trie:

\vskip 1mm
\qquad$\bullet$ In some cases, tries can be slower than hash tables while searching data. This is true in cases when the data is directly accessed on a hard disk drive or some other secondary storage device that has high randome access time as compated to the main memory.

\vskip 3mms
\qquad$\bullet$ All the key values cannot be easily represented as strings.

\vskip 3mm
{\bf Applications}

\vskip 1mm
Tries are commonly used to store a dictionary. These applications take advantage of a trie's ability to quickly search, insert, and delete the entries. Tries are also used to implement approximate matching algorithms, including those used in spell-checking software.

\filbreak
\vskip 1cm
{\bf Points to Remember}

\vskip 1mm
$\bullet$ An M-way search tree has $M-1$ values per node and $M$ sub-trees. In such a tree $M$ is called the degree of the tree. $M$-way search tree consists of pointers to $m$ sub-trees and contains $M-1$ keys, where $M>2$.

\vskip 3mm
$\bullet$ A B-tree of order $m$ can have a maximum of $m-1$ keys and $m$ pointers to its sub-trees. A B-tree may contain a large number of key values and pointers to its sub-trees.

\vskip 3mm
$\bullet$ A B+ tree is a variant of B-tree which stores sorted data in a way that allows for efficient insertion, retrieval and removal of records, each of which is identified by a key. B+ tree record data at the leaf level of the tree; only keys are stored in interior nodes.

\vskip 3mm
$\bullet$ A trie is an ordered tree data structure which stores keys that are usually strings. It is basically a $k$-ary position tree.

\vskip 3mm
$\bullet$ In contrast to binary search trees, nodes in a trie do not store the keys associated with them. Rather, a node's position in the tree represents the key associated with that node.

\vskip 3mm
$\bullet$ In a 2-3 tree, each interior node has either two or three children. This means that a 2-3 tree is not a binary tree.


%$$\vbox{\+\bf \cleartabs& \cr
%	\+\cr
%	\+\cr
%	\+\cr}$$

\vfill\eject
\bye
