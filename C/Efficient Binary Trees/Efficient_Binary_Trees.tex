{\bf Efficient Binary Trees}
\vskip 1mm
\hrule

\vskip 3mm
{\bf Operations On Binary Search Trees}
\vskip 1mm
These operations are available for all Binary Search Trees. All these operations require comparisons to be made between the nodes.

\vskip 1cm
{\bf Searching for a Node in a Binary Search Tree}

\vskip 1mm
The search function is used to find whether a given value is present in the tree or not. The searching process begins at the root node. The function checks if the binary search tree is empty. If it is empty, then the value we are searching for is not present in the tree. The search algorithm terminates by displaying an appropriate message. However, if there are nodes in the tree, then the search function checks to see if the key value of the current node is equal to the value of the value to be searched. If not, it checks if the value to be searched for is less than the value of the current node, in which case it be recursively called on the left child node. In case the value is greater than the value of the current node, it should be recursively called on the right child node.

\filbreak
\vskip 1cm
{\bf Inserting a New Node in a Binary Search Tree}
\vskip 1mm
The insert function is used to add a new node with a given value at the correct position in the binary search tree. Adding the node at the correct position means that the new node should not violate the properties of the binary search tree.

\filbreak
\vskip 1cm
{\bf Deleting a Node from a Binary Search Tree}
\vskip 1mm
The delete function deletes a node from the binary search tree. However, utmost care should be taken that the properties of the binary search tree are not violated and nodes are not lost in the process.
Case in Which a node is deleted from a binary search tree

\vskip 3mm
{\bf Case 1: Deleting a Node that has no Children}

\vskip 1mm
Simply remove the node. This is the simplist case.

\vskip 2mm
{\bf Case 2: Deleting a Node with One Child}

\vskip 1mm
To hanlde this case, the node's child is set as the childe of the node's parent. In other words,  replace the node with its child. Now, if the node is the left child of its parent, the node's child becomes the left child of the node's parent. Correspondingly, if the node is the right child of its parent, the node's child becomes the right child of the node's parent.

\vskip 2mm
{\bf Case 3: Deleting a Node with Two Children}

\vskip 1mm
Th handle this case, replace the node's value with its {\bf in-order predecessor} (largest value in the left sub-tree). The {\bf in-order} predecessor or the successor can then be deleted using any of the above cases.

\filbreak
\vskip 1cm
{\bf Determing the Height of a Binary Search Tree}

\vskip 1mm
In order to determine the height of a binary search tree, we calculate the height of the left sub-trr and the right sub-tree. Whichever height is greater, 1 is added to it.

\filbreak
\vskip 1cm
{\bf Determining the Number of Nodes}

\vskip 1mm
Determining the number of nodes in a binary search tree is similar to determining its height. To calculate the total number of elements/nodes in the tree, we count the number of nodes in the left sub-tree and the right sub-tree.

$$\hbox{\tt Number of nodes = totalNodes(left sub-tree) + totalNodes(right sub-tree) + 1}$$

\vskip 3mm
{\bf Determing the Number of Internal Nodes}

\vskip 1mm
To calculate the total number of internal nodes or non-leaf nodes, we count the number of internal nodes in the left sub-tree and the right sub-tree and add 1 to it ( 1 is added for the root node).

$$\hbox{\tt Number of internal nodes = }$$
\vskip 1mm
$$\hbox{\tt totalInternalNodes(left sub-tree + totalInteralNodes(right sub-tree) + 1}$$

\vskip 2mm
{\bf Determinging the Number of External Nodes}

\vskip 1mm
To calculate the total number of external nodes or leaf nodes, we add the number of external nodes in the left sub-tree and the right sub-tree. However if the tree is empty, that is {\tt TREE = NULL}, then the number of external nodes will be zero. But if there is only one node in the tree, then the number of external nodes will be one.

$$\hbox{\tt Number of external nodes = }$$
\vskip 1mm
$$\hbox{\tt totalExternalNoses(left sub-tree) + totalExternalNodes(right sub-tree)}$$

\filbreak
\vskip 1cm
{\bf Finding the Mirror Image of a Binary Search Tree}
\vskip 1mm
Mirror image of a binary search tree is obtained by interchanging the left sub-tree with the right sub-tree at every node of the tree. Given a tree $T$, the mirror image of $T$ can be obtained as $T'$.

\filbreak
\vskip 1cm
{\bf Deleting a Binary Search Tree}
\vskip 1mm
To delete/remove an entire binary search tree from the memory, we first delete the elements/nodes in the left sub-tree and then delete the nodes in the right sub-tree.

\filbreak
\vskip 1cm
{\bf Finding the Smallest Node in a Binary Search Tree}

\vskip 1mm
The very basic property of the binary search tree states that the smaller value will occur in the left sub-tree. If the left sub-tree is {\tt NULL}, then the value of the root node will be smallest as compared to the nodes in the right sub-tree. So, to find the node with the smallest value, we find the value of the leftmost node of the left sub-tree.

\filbreak
\vskip 1cm
{\bf Finding the Largest Node in a Binary Search Tree}

\vskip 1mm
To find the node with the largest value, we find the value of the right most node of the right sub-tree. However, if the right sub-tree is empty, then the root node will be the largest value in the tree.

\filbreak
\vskip 1cm
{\bf Threaded Binary Trees}
\vskip 1mm
A threaded binary tree is the same as that of a binary tree but with a difference in storing the {\tt NULL} pointers. In the linked representation, a number of nodes contain a {\tt NULL} pointer, either in their lef or right fields or in both. This space that is wasted in storing a {\tt NULL} pointer can be efficiently used to store other useful information. For example, the {\tt NULL} entries can be replaced to store a pointer to the in-order predecessor or the in-order successor of the node. These special pointers are called {\bf threads} and binary  trees containing threads are called {\bf threaded trees}. A threaded binary tree may correspond to one-way threading or a two-way threading.

\vskip 1mm
In one-way threading, a thread will appear either in the right field or the left field of the node. A one-way threaded tree is also called a single-threaded tree. If the thread appears in the left field, then the left field will be made to point to the in-order predecessor of the node. Such a threaded binary a one-way threaded tree is called a left-threaded binary tree. On the contrary, if the thread appears in the right field, then it will point to the in-order successor of the node. Such a one-way threaded tree is called a tight-threaded binary tree.

\vskip 1mm
In a two-way threaded tree, also called a double-threaded tree, threads will appear in both the left and the right field of the node. While the left field will point to the in-order predecessor of the node, the, the right field will point to its sucessor. A two-way threaded binary tree is also called a fully threaded binary tree.

\filbreak
\vskip 1cm
{\bf Traversing a Threaded Binary Tree}

\vskip 1mm
For every node, visit the left sub-tree firs, provided if one exists and has not been visited earlier. Then the node (root) itself is followed by visiting its right sub-tree (if one exists). In case there is no right sub-tree, check for the threaded link and make the threaded node the current node in consideration.

\vskip 3mm
{\bf Advantages of Threaded Binary Tree}

\qquad$\bullet$ It enables linear traversal of elements in the tree.

\vskip 3mm
\qquad$\bullet$ Linear traversal eliminates the use of stacks which in turn consume a lot of memory space and computing time.

\vskip 3mm
\qquad$\bullet$ I enables to find the parent of a given element without explicit use of parent pointers.

\vskip 3mm
\qquad$\bullet$ Since nodes contain pointers to in-order predecessor and successor, the threaded tree enables forward and backward traversal of the nodes as given by in-order fashion.

\vskip 3mm
Thus, the basic difference between a binary tree and a threaded binary tree is that in binary trees a node stores a {\tt NULL} pointer if it has no child and there is no way to traverse back.

\filbreak
\vskip 1cm
{\bf AVL Trees}
\vskip 1mm
AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two sub-trees of a node may differ by a most one. Due to this property , the AVL tree is also known as a height-balance tree.

\vskip 1mm
The structure of an AVL tree is the same as that of a binary search tree. In its structure, it stores an additional variable called the {\tt BalanceFactor}. Thus, every node has a balance factor assocaiated with it. The balance factor of a node is calculated by subtracting the height of its right sub-tree from the height of its left sub-tree. A binary search tree in which every node has a balance $-1,0$ or $1$ is said to be height balanced. A node with any other balance factor is considered to be unbalanced and requires rebalancing of the tree.

$\bullet$ If the balance factor of a node is $1$, then it means that the left sub-tree of the tree is one level higher than that of the right sub-tree. Such a tree is therefore called as a {\bf left-heavy tree}
\vskip 3mm
$\bullet$ If the balance factor of a node is $0$, then it means that the height of the left sub-tree (longest path in the left sub-tree) is equal to the height of the right sub-tree.

\vskip 3mm
$\bullet$ If the balance factor of a node is $-1$, then it means that the left sub-tree of the tree is one level lower than that of the right sub-tree. Such a tree is therefore called a {\bf right-heavy tree}.

$$\hbox{\tt Balance factor = Height(left sub-tree) - Height(right sub-tree)}$$

Insertions and deletions from an AVL tree may  disturb the balance factor of the nodes and thus, rebalancing of the tree may have to be done. The tree is rebalanced by performing rotation at the critical node. There are four types of rotations: {\tt LL} rotation, {\tt RR} rotation, {\tt LR} rotation, and {\tt RL} rotation. The type of rotation that has to be donw will vary depending on the particular situation.

\filbreak
\vskip 1cm
{\bf Operations on AVL Trees}

\vskip 3mm
{\bf Searching for a Node in an AVL Tree}
\vskip 1mm
Searching in an AVL tree is also done in the same way it is done in a binary tree. In the AVL tree, the new node is always inserted as the leaf node. But the step of insertion is usually followed by an additional step of rotation. Rotation is done to restore the balance of the tree. However, if insertion of the new node does not distrub the balance factor, that is, if the balance factor of every node is still $-1,0$ or $1$, then rotations are not required.

\vskip 1mm
During insertion, the new node is inserted as the leaf node, so it will have a balance factor equal to zero. The only nodes whose balance factors will change are those which lie in the path between the root of the tree and the newly inserted node. The possibility changes which may take place in any node on the path as follow:

\vskip 1mm
\qquad$\bullet$ Initially, the node was either left- or right-heavy and after insertion, it becomes balanced.

\vskip 3mm
\qquad$\bullet$ Initially, the node was balanced and after insertion, it becomes either left- or right-heavy.

\vskip 3mm
\qquad$\bullet$ Initially, the node was heavy (either left or right) and the new node has been inserted in the heavy sub-tree, thereby creating an unbalanced sub-tree. Such a node is said to be a critical node.

\vskip 3mm
To perform a rotation, our first task is to find the critical node. Critical node is the nearest ancestor node on the path from the inserted node to the root whose balance factor is neither $-1,0$ nor $1$. The second task in rebalancing the tree is to determine which type of rotation has to be done. There are four types of rebalancing rotations and applications of these rotations depends on the position of the inserted node with reference to the criticsl node. The four categories are:

\vskip 1mm
$\bullet$ {\tt LL} rotation\qquad The new node is inserted in the left sub-tree of the left sub-tree of the critical node.

\vskip 3mm
$\bullet$ {\tt RR} rotation\qquad The new node is inserted in the right sub-tree of the right sub-tree of the critical node.

\vskip 3mm
$\bullet$ {\tt LR} rotation\qquad The new node is inserted in the right sub-tree of the left sub-tree of the critical node.

\vskip 3mm
$\bullet$ {\tt RL} rotation\qquad The new node is inserted in the left sub-tree of the right sub-tree of the critical node.

\vskip 3mm
{\bf Deleting a Node from an AVL Tree}

\vskip 1mm
Deletion of a node in a AVL tree is similar to that of a binary search trees. Deletion may disturb the AVLness of the tree, so to rebalance the AVL tree, we need to perform rotations. There are tewo classes of rotations that can be performed on an AVL tree after deleting a given node. There rotations are $R$ and $L$ rotation.

\vskip 1mm
On deletion of node $x$ from the AVL tree, if node $A$ becomes the critical node (closest ancestor node on the path from $x$ to the root node that does not have its balance factor as $1,0$ or $-1$, then the type of rotation depdens on whether $x$ is in the left sub-tree of $A$ or in its right sub-tree. If the node to be deleted is present in the left sub-tree of $A$, then $L$ rotation is applied, else if $x$ is in the right sub-tree, $R$ rotation is performed.

\vskip 1mm
Further, there are three categories of $L$ and $R$ rotations. The variations of $L$ rotation are $L-1$, $L0$, and $L1$ rotation. Correspondingly for $R$ rotation, there are $R0$, $R-1$, and $R1$ rotations.

\vskip 3mm
{\bf $R0$ Rotation}
\vskip 1mm
Let $B$ be the root of the left or right sub-tree of $A$ (critical node). $R0$ is applied if the balance factor of $B$ is $0$.

\vskip 3mm
{\bf $R1$ Rotation} 
\vskip 1mm
Let $B$ be the root of the left or right sub-tree of $A$ (critical node). $R1$ rotation is applied if the balance factor of $B$ is $1$. Observe that $R0$ and $R1$ rotations are similiar to $LL$ rotations; the only difference is that $R0$ and $R1$ rotations yield different balance factors.

\vskip 3mm
{\bf $R-1$ Rotations}
\vskip 1mm
Let $B$ be the root of the left or right sub-tree of $A$ (critical node). $R-1$ rotation is applied if the balance factor of $B$ is $-1$ rotation is similar to $LR$ rotation.

\filbreak
\vskip 1cm
{\bf Red-Black Trees}

\vskip 1mm
A red-black tree is a self-balancing binary search tree. Practically, a red-black tree is a binary search tree which inserts and removes intelligently, to keep the tree reasonably balanced. A special point to note about the red-black tree is that in this tree, no data is store in the leaf nodes.

\filbreak
\vskip 1cm
{\bf Properties of Red-Black Trees}

\vskip 1mm
A red-black tree is a binary search tree in which every node has a color which is either red or black. Apart from the other restrictions of a binary search tree, the red-black tree has the following additional requirements:

\qquad(1) The color of a node is either red or black

\vskip 3mm
\qquad(2) The color of the root node is always black

\vskip 3mm
\qquad(3) All leaf nodes are black

\vskip 3mm
\qquad(4) Every red node has both the children colored in black.

\vskip 3mm
\qquad(5) Every simple path from a given node to any of its leaf nodes has an equal number of black nodes.

\vskip 2mm
These constraints enforce a critical property of red-black trees. The longest path from the root node to any leaf is no more than twice as long as the shortest path from the root to any other leaf in that tree.

\filbreak
\vskip 1cm
{\bf Operations on Red-Black Trees}

\vskip 1mm
Preforming a read-only operation (like traversing the nodes in a tree) on a red-black tree is a special case of a binary tree. However, insertion and deletion operations may violate the properties of a red-black search tree.

\vskip 3mm
{\bf Inserting a Node in a Red-Black Tree}

\vskip 1mm
The insertion operation starts in the same way as we add a new node in the binary search tree. However, in a binary search tree, we always add the new node as a leaf. while in a red-black tree, leaf nodes contain no data. So instead of adding a new leaf node, we add a red interior node that has two black leaf nodes. Note that the color of the new node is red and its leaf nodes are colored black.

\vskip 1mm
Once a new node is added, it may violate some properties of the red-black tree. So in order to restore their property, we check for certain cases and restore the property depdending on the case that turns up after insertion.

\vskip 1mm
{\bf Grandparent node} $(G)$ of a node $(N)$ refers to the parent of $N$'s parent $(P)$. The C code to find a node's grandparent can be given as follows:

$$\vbox{\+\tt struct \cleartabs&\tt node* grand$\_$parent(struct node *n) $\{$\cr
	\+&\bf// No parent means no grandparent\cr
	\+&\tt if((n\cleartabs&\tt{} $\neq$ NULL $\&\&$ (n -> parent $\neq$ NULL))\cr
	\+&&\tt return n-> parent -> parent;\cr
	\+\tt else\cr
	\+&&\tt return NULL;\cr
	\+\tt$\}$\cr}$$

{\bf Uncle node} $(U)$ of a node $(N)$ refers to the sibling of $N$'s parent $(P)$

$$\vbox{\+\tt struct \cleartabs&\tt node* g $\{$\cr
	\+\tt g = grand$\_$parent(n);\cr
	\+\bf // With no grandparent, there cannot be any uncle\cr
	\+\tt if(g == NULL)\cr
	\+&\tt return NULL;\cr
	\+\tt if(n -> parent == g -> left)\cr
	\+&\tt return g -> right;\cr
	\+\tt else\cr
	\+&\tt return g -> left;\cr
	\+\tt$\}$\cr}$$

When we insert a new node in a red-black tree, note the following

\vskip 1mm
\qquad$\bullet$ All leaf nodes are always black. So property 3 always holds true.

\vskip 3mm
\qquad$\bullet$ Property 4 (both children of every red node are black) is threatened only by adding a red node, repainting a black node red, or a rotation,

\vskip 3mm
\qquad$\bullet$ Property 5 (all paths from any given node to its leaf node has equal number of black nodes) is threatened only by adding a black node, repainting a red node black, or a rotation.

\filbreak
\vskip 3mm
{\bf Case 1: The New Node $N$ is Added as the Root of the tree}
\vskip 1mm
In this case, $N$ is repainted black, as the root of the tree is always black. Since $N$ adds one black node to every path at once, Property 5 is not violated. The C code for case 1 can be given as

$$\vbox{\+\tt void \cleartabs&\tt case1(struct node* n) $\{$ \cr
	\+&\tt if(n\cleartabs&\tt -> parent == NULL\qquad\hbox{\bf // Root node}\cr
	\+&&\tt n -> color = BLACK;\cr
	\+&\tt else\cr
	\+&&\tt case2(n)\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 2: The New Node's Parent $P$ is Black}

\vskip 1mm
In this case, both children of every red node are black, so Property 4 is not invalidated. Property 5 is also  not threatened. This is because the new node $N$ has two black leaf children, but because $N$ is red, the paths through each of its children have the same number of black nodes. The C code to check for case 2 can be given as:

$$\vbox{\+\tt void \cleartabs&\tt case2(struct node* n) $\{$ \cr
	\+&\tt if(n\cleartabs&\tt -> parent == BLACK\cr
	\+&&\tt return;\qquad\hbox{\bf /* Red black tree property is not violated */}\cr
	\+&\tt else\cr
	\+&&\tt case3(n)\cr
	\+\tt$\}$\cr}$$

In the following cases, it is assumed that $N$ has a grandparent nde $G$, because its parent $P$ is red, and if it were the root, it would be black. Thus, $N$ also has an uncle node $U$

\filbreak
\vskip 3mm
{\bf Case 3: If Both the Parent $(P)$ and the Uncle $(U)$ are Red}

\vskip 1mm
In this case, Property 5 which says all paths from any given node to its leaf nodes have an equal number of black nodes is violated. In order to restore Property 5, both nodes $(P\hbox{ and } U)$ are repainted black and the grandparent $G$ is repainted red. Now, the new red node $N$ has a black parent. Since any path through the parent or uncle must pass through the grandparent, the number of black nodes on these paths has not changed.

\vskip 1mm
However, the grandparent $G$ may now violate Property 2 which says that the root node is always black or Property 4 which states that both children of every red node are black. Property 4 will be violated when $G$ has a red parent. In order to fix this problem, this entire procedure is recursively performed on $G$ from Case 1. The $C$ code to deal with Case 3 insertion can be given as:

$$\vbox{\+\tt void \cleartabs&\tt case3(struct node* n) $\{$ \cr
	\+&\tt struct node *u, *g;\cr
	\+&\tt u = uncle(n);\cr
	\+&\tt g = grand$\_$parent(n)\cr
	\+&\tt if((i\cleartabs&\tt $\neq$ NULL) $\&\&$ (u -> color == RED)) $\{$\cr
	\+&&\tt n -> parent -> color = BLACK;\cr
	\+&&\tt u -> color = BLACK;\cr
	\+&&\tt g -> color = RED;\cr
	\+&&\tt Case1(g);\cr
	\+&\tt$\}$\cr
	\+&\tt else $\{$\cr
	\+&&\tt insert$\_$case4(n);\cr
	\+&\tt$\}$\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 4: The Parent $P$ is Red but the Uncle $U$ is Black and $N$ is the Right Child of $P$ and $P$ is the Left Child of $G$}

\vskip 1mm
In order to fix this problem, a left rotation is done to switch the roles of the new node $N$ and its parent $P$. After the rotation, note in the C code, we have re-labelled $N$ and $P$ and then, Case 5 is called to deal with the node's parent. This is done because Property 4 which says both children of every node should be black is still violated. Noted that in case $N$ is the left child of $P$ and $P$ is the right child of $G$, we have to perform a right rotation. In the C code that handles Case 4, we check for $P$ and $N$ and then, perform either a left or right rotation.

$$\vbox{\+\tt void \cleartabs&\tt case4(struct node* n) $\{$ \cr
	\+&\tt struct node *g = grand$\_$parent(n);\cr
	\+&\tt if((n\cleartabs&\tt == n -> parent -> right) $\&\&$ (n -> parent == g -> left)) $\{$\cr
	\+&&\tt rotate$\_$left(n -> parent);\cr
	\+&&\tt n = n -> left;\cr
	\+&\tt $\}$\cr
	\+&\tt else if((n == n-> left) $\&\&$ (n -> parent == g -> right)) $\{$\cr
	\+&&\tt rotate$\_$right(n -> parent);\cr
	\+&&\tt n = n -> right;\cr
	\+&\tt$\}$\cr
	\+&\tt case5(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 5: The Parent $P$ is Red but the Uncle $U$ is Black and the New Node is the Left Child of $P$, and $P$ is the Left Child of its Parent $G$}

\vskip 1mm
In order to fix this problem, a right rotation on $G$ (the grandparent of $N$) is performed. After this rotation, the former parent $P$ is now the parent of both the new node $N$ and the former grandparent $G$. We know that the color of $G$ is black (because otherwise its former child $P$ could not have been red), so now switch the colors of $P$ and $G$ so that the resulting tree satisfies Property 4 which states that both children of a red node are black. Note that in case $N$ is the right child of $P$ and $P$ is the right child of $G$, we perform a left rotation. In the C code that handles Case 5, we check for $P$ and $N$ and then, perform either a left or a right rotation.

$$\vbox{\+\tt void \cleartabs&\tt case5(struct node* n) $\{$ \cr
	\+&\tt struct node *g;\cr
	\+&\tt if((n\cleartabs&\tt == n -> parent -> left) $\&\&$ (n -> parent == g -> left))\cr
	\+&&\tt rotate$\_$right(g);\cr
	\+&\tt else if((n == n-> left) $\&\&$ (n -> parent == g -> right))\cr
	\+&&\tt rotate$\_$left(g);\cr
	\+&\tt n -> parent -> color = BLACK;\cr
	\+&\tt g -> color = RED;\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Deleting a Node from a Red-Black Tree}

\vskip 1mm
We start deleting a node from a red-black tree in the same way we do in case of a binary search tree. In a binary seach tree, when we delete a node with non-leaf children, we find either the maximum element in its left sub-tree of the node or the minimum element in its right sub-tree, and move its value into the node being deleted. After that, we delete the node from which we had copied the value. Note that this node must have less than two non-leaf children. Therefore, merely copying a value does not violate any red-black properties, but it just reduces the problem of deleting to the problem of deleting a node with at most one non-leaf child.

\vskip 1mm
While deleting a node, if its color is red, then we can simply replace it with its child, which must be black. All paths through the deleted node will simply pass through one less red node, and both the deleted node's parent and child must be black, so none of the properties will be violated.

\vskip 1mm
Another simple case is when we delete a black node that has a red child. In this case, Property 4 and Property 5 could be violated, so to restore them, just repaint the deleted node's child with black.

\vskip 1mm
A complex situation arises when both  the node to be deleted as well as its child is label the child node as (in its new position) $N$, and its siblings (its new parent's other child) as $S$. The C code to find the sibling of a node can be given as:

$$\vbox{\+\tt struct \cleartabs&\tt node *sibling(struct node *n) $\{$ \cr
	\+&\tt if(n\cleartabs&\tt == n-> parent ->)\cr
	\+&&\tt return n -> parent -> right;\cr
	\+&\tt else\cr
	\+&&\tt return n -> parent -> left;\cr
	\+\tt$\}$\cr}$$

We can start the deletion process by using the following code, where the function {\tt replace$\_$node} substitutes the {\tt child} into $N$'s place in the tree. We assume null leaves are represented by actual node object, rather than {\tt NULL}.

$$\vbox{\+\tt void \cleartabs&\tt delete$\_$child(struct node *n) $\{$ \cr
	\+&\bf /* If $N$ has at most one non-null child */\cr
	\+&\tt struct node *child;\cr
	\+&\tt if(is$\_$leaf\cleartabs&\tt(n -> right))\cr
	\+&&\tt child = n -> left;\cr
	\+&\tt else\cr
	\+&&\tt child = n -> right;\cr
	\+&\tt replace$\_$node(n, child);\cr
	\+&\tt if(n -> color == BLACK) $\{$\cr
	\+&&\tt if(child\cleartabs&\tt -> color == RED)\cr
	\+&&&\tt child -> color == BLACK;\cr
	\+&&\tt else\cr
	\+&&&\tt del$\_$case1(child);\cr
	\+&&$\}$\cr
	\+&&\tt free(n);\cr
	\+\tt$\}$\cr}$$

When both $N$ and its parent $P$ are black, then deleting $P$ will cause paths which precede through $N$ to have one fewer black nodes than the other paths. This will violate Property 5. Therefore, the tree needs to be reblanced. There are several cases to consider.

\filbreak
\vskip 3mm
{\bf Case 1: $N$ is the New Root}

\vskip 1mm
In this case, we hve removed one black node from every path, and the new root is black, so none of the properties are violated.

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case1(struct node *n) $\{$ \cr
	\+&\tt if( n\cleartabs&\tt -> parent $\neq$ NULL)\cr
	\+&&\tt del$\_$case2(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 2: Sibling $S$ is Red}

\vskip 1mm
In this case, interchange the colors of $P$ and $S$, and then rotate left $P$. In the resultant tree, $S$ will become $N$'s grandparent. The C code that handles Case 2 deletion can be given as

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case2(struct node *n) $\{$ \cr
	\+&\tt struct node *s;\cr
	\+&\tt s = sibling(n);\cr
	\+&\tt if(s\cleartabs&\tt -> color == RED) $\{$\cr
	\+&&\tt if(n\cleartabs&\tt == n -> parent -> left)\cr
	\+&&&\tt rotate$\_$left(n -> parent);\cr
	\+&&\tt else\cr
	\+&&&\tt rotate$\_$right(n -> parent);\cr
	\+&&\tt n -> parent -> color = RED;\cr
	\+&&\tt s -> color = BLACK;\cr
	\+&\tt$\}$\cr
	\+&\tt del$\_$case3(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 3: $P,S$ and $S$'s Children are Black}

\vskip 1mm
In this case, simply repaint $s$ with red. In the resultant tree, all the paths passing through $S$ will have one less black node. Therefore, all the paths that pass through $P$ now have one fewer black nodes than the path that do not pass through $P$, So Property 5 is still violated. To fix this problem, we perform the rebalancing procedure on $P$, starting at Case 1. The C code fo Case 3 can be given as:

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case3(struct node *n) $\{$ \cr
	\+&\tt struct node *s;\cr
	\+&\tt s = sibling(n);\cr
	\+\tt{}\cr
	\+&\tt if((n\cleartabs&\tt -> parent -> color == BLACK) $\&\&$ (s -> color == Black) $\&\&$ \cr
	\+&\tt (s -> left -> color == BLACK $\&\&$ (s -> right-color == BLACK)) $\{$ \cr
	\+&&\tt s -> color = RED;\cr
	\+&&\tt del$\_$case1(n -> parent);\cr
	\+&&\tt $\}$ else\cleartabs&\tt\cr
	\+&&&\tt del$\_$case4(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 4: $S$ and $S$'s Children are Black, but $P$ is Red}

\vskip 1mm
In this case, we interchange the colors of $S$ and $P$. Although this will not affect the number of black nodes on the paths going through $S$, it will add one black node to the paths going through $N$, making up for the deleted black node on those paths. The C code handle Case 4 can be given as:

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case4(struct node *n) $\{$ \cr
	\+&\tt struct node *s;\cr
	\+&\tt s = sibling(n);\cr
	\+\tt{}\cr
	\+&\tt if((n\cleartabs&\tt -> parent -> color == RED) $\&\&$ (s -> color == Black) $\&\&$ \cr
	\+&\tt (s -> left -> color == BLACK $\&\&$ (s -> right-color == BLACK)) $\{$ \cr
	\+&&\tt s -> color = RED;\cr
	\+&&\tt n -> parent -> color = BLACK;\cr
	\+&&\tt $\}$ else\cleartabs&\cr
	\+&&&\tt del$\_$case5(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 5: $N$ is the Left Child or $P$ and $S$ is Black, $S$'s Left Child is Red, $S$'s Right Child is Black}

\vskip 1mm
In this case, perform a right rotation at $S$. After the rotation, $s$'s left child becomes $S$'s parent and $N$'s new sibling. Also, interchange the colors of $S$ and its new parent. Note that all paths still have equal number of black nodes, but $N$ has a black sibling whose right child is red, So we fall into Case 6. The C code to hanle Case 5 is given as:

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case5(struct node *n) $\{$ \cr
	\+&\tt struct node *s;\cr
	\+&\tt s = sibling(n);\cr
	\+\tt{}\cr
	\+&\tt if(s\cleartabs&\tt -> color == BLACK) $\{$\cr
	\+&\bf /* the following code forces the red to be on the left of the left of the parent\cr
	\+&\bf * or right of the right, to be correctly operated in Case 6. \cr
	\+&&\tt if((n\cleartabs&\tt -> parent -> left) $\&\&$ (s -> right -> color == BLACK) $\&\&$ \cr
	\+&&&\tt (s -> left -> color == RED)) \cr
	\+&&\tt else if ((n == n -> parent -> right) $\&\&$ (s -> left -> color == BLACK) $\&\&$\cr
	\+&&\tt s -> right -> color == RED))\cr
	\+&&\tt rotate$\_$left(s);\cr
	\+&&\tt s -> color == RED;\cr
	\+&&\tt s -> right -> color = BLACK;\cr
	\+&$\tt\}$\cr
	\+&\tt del$\_$case6(n);\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Case 6: $S$ is Black, $S$'s Right Child is Red, and $N$ is the Left Child of its Parent $P$}

\vskip 1mm
In this case, a left rotation is done at $P$ to make $S$ the parent of $P$ and $S$'s right child. After the rotation, the colors of $P$ and $S$ are interchanged and $S$'s right child is colored black. One these steps are followed, you will observed that Property 4 and Property 5 remain vaild. The C code to fix ase 6 can be given as:

$$\vbox{\+\tt void \cleartabs&\tt del$\_$case5(struct node *n) $\{$ \cr
	\+&\tt struct node *s;\cr
	\+&\tt s = sibling(n);\cr
	\+&\tt s -> color = n -> parent -> color;\cr
	\+&\tt n -> parent -> color = BLACK;\cr
	\+\tt{}\cr
	\+&\tt if(n\cleartabs&\tt == n -> left) $\{$\cr
	\+&&\tt s -> right -> color = BLACK;\cr
	\+&&\tt rotate$\_$left(n -> parent);\cr
	\+&\tt $\}$ else $\{$\cr
	\+&&\tt s -> right -> color == BLACK \cr
	\+&&\tt rotate$\_$right(n -> parent);\cr
	\+&$\tt\}$\cr
	\+\tt$\}$\cr}$$

\filbreak
\vskip 3mm
{\bf Applications of Red-Black Trees}

\vskip 1mm
Red-black trees are not only valuable in time-sensitive applications such as real-time applications, but are also preferred to be used as a building block in other data structures which provide worst-case guarantee.

\filbreak
\vskip 1cm
{\bf Splay Trees}
\vskip 3mm
A splay tree is a self-balancing binary search tree with an additional property that recently accessed elements can be re-accessed fast. For many non-uniform sequences of operations, splay trees perform better than other search trees, even when the specific pattern of the sequence is unknown.

\vskip 1mm
A splay tree consists of a binary tree, with no additional fields. When a node in a splay tree is accessed, it is rotated or 'splayed' to the root, thereby changing the structure of the tree. Since the most frequently accessed node is always moved closer to the starting point (the root node), these nodes are therefore located faster.

\vskip 1mm In a splay tree, operations such as insertions, search, and deletion are combined with one basic operation called {\bf splaying}. Splaying the tree for a particular node rearranges the tree to place that node at the root. A technique to do this is to first perform a standard binary tree search for that node and then use rotation in a specific order to bring the node on top.

\filbreak
\vskip 3mm
{\bf Operations on Splay Trees}

\vskip 1mm
The four main operations that are performed on a splay tree. These include splaying, insertion, search, and deletion.

\vskip 2mm
{\bf Splaying}
\vskip 1mm
When we access a node $N$, splaying is performed on $N$ to move it to the root. To perform a splay operation, certain {\bf splay steps} are performed where each step moves $N$ to the root. Splaying a particular node of interest after the tree remains roughly balanced.

\vskip 1mm
Each splay step depends on three facts:

\vskip 1mm
\qquad$\bullet$ Whether $N$ is the left or right child of its parent $P$

\vskip 3mm
\qquad$\bullet$ Whether $P$ is the root or not, and if not

\vskip 3mm
\qquad$\bullet$ Whether $P$ is the left or right child of its parent, $G$ ($N$'s grandparent).

Depending on these factors, we have one splay step on each factor.

\vskip 2mm
{\bf Zig step}
\vskip 1mm
The {\tt zig} operation is done when $P$ (the parent of $N$) is the root of the splay tree. In the {\tt zig} step, the tree is rotated on the edge between $N$ and $P$. {\tt zig} step is usually performed as the last step in a splay operation and only when $N$ has an odd depth at the beginning of the operation.

\vskip 3mm
{\bf Zig-zig step}

\vskip 1mm
The {\tt zig-zig} operation is performed when $P$ is not the root. In addition to this, $N$ and $P$ are either both right or left children of their parents. During the {\tt zig-zig} step, first the tree is rotated on the edge joining $P$ and its parent $G$, and then again rotated on the edge $N$ and $P$.

\vskip 3mm
{\bf Zig-zag step} The {\tt zig-zag} operation is performed when $P$ is not the root. In addition to this, $N$ is the right child of $P$ and $P$ is the left child of $G$ or vice verse. In {\tt zig-zag}, the tree is first rotated on the edge between $N$ and $P$, and then rotated on the edge between $N$ and $G$.

\vskip 3mm
{\bf Inserting a Node in a Sply Tree}

\vskip 1mm
Although the process of inserting a new node into a splay tree begins in the same way as we insert a node in a binary search tree, but after the insertion, $N$ is made the new root of the splay tree. The steps performed to insert a new node $N$ in a splay tree can be given as:

\vskip 2mm
{\bf Step 1}\qquad Search $N$ in the splay tree. If the search is successful, splay at the node $N$.

\vskip 3mm
{\bf Step 2}\qquad If the search is unsuccessful, add the new node $N$ in such a way that it replaces the {\tt NULL} pointer reached during the search by a piinter to a new node $N$. Splay the tree at $N$.

\vskip 3mm
{\bf Searching a Node in a Splay Tree}

\vskip 1mm
If a particular node $N$ is present in the splay tree, then a pointer to the null node is returned. The steps performed to search a node $N$ in a splay tree include:

\vskip 2mm
\qquad$\bullet$ Search down the root of the splay tree looking for $N$.

\vskip 3mm
\qquad$\bullet$ If the search is successful, and we reach $N$, then splay the tree at $N$ and return a pointer to $N$.

\vskip 3mm
\qquad$\bullet$ If the search is unsuccessful, i.e., the splay tree does not contain $N$, then we reach a null node. Splay the tree during the search and return a pointer to null.


\vskip 3mm
{\bf Deleting a Node from a Splay Tree}

\vskip 1mm
To delete a node $N$ from a splay tree, we perform the following steps:

\vskip 2mm
\qquad$\bullet$ Search for $N$ that has to be deleted. If the search us unsuccessful, splay the tree at the last non-null node encountered during the search.

\vskip 3mm
\qquad$\bullet$ If the search is successful and $N$ is not the root node, then let $P$ be the prent of $N$. Replace $N$ by an appropriate descendent of $P$. Finally splay the tree.

\vskip 3mm
{\bf Advantages and Disadvantages of Splay Trees}

\vskip 1mm
The advantages of using a splay tree are:

\vskip 2mm
\qquad$\bullet$ A splay tree gives good performance for search, insertion, and deletion operations. This advantage centers on the fact that the splay tree is a self-balancing and a self-optimizing data structure in which the frequently accessed nodes are moved closer to the root so that they can be accessed quickly. This advantage is particularly useful for implementing caches and garbage collection algorithms.

\vskip 3mm
\qquad$\bullet$ Splay trees are considerably simpler to implement than the other self-balancing binary search trees, such as red-black trees or AVL trees, while their average-case performance is just as efficient.

\vskip 3mm
\qquad$\bullet$ Splay trees minimize memory requirements as they do not store any book-keeping data.

\vskip 3mm
\qquad$\bullet$ Unlike other types of self-balancing trees, splay trees provide good performance with nodes containing identical keys.

\vskip 3mm
However, here are some disadvantages of splay trees:

\vskip 3mm
\qquad$\bullet$ While sequentially accessing all the nodes of a tree in a sorted order, the resultant tree becomes completely unbalanced. This takes $n$ accesses of the tree in which each access in turn takes  $O(\log n)$ time. For example. re-accessing the first node triggers an operation that in turn takes $O(n)$ operations to rebalance the tree before returning the first node. Although this creates a signigicant delay for the final operation, the amortized performance over the entire sequence is still $O(\log n)$.

\vskip 3mm
\qquad$\bullet$ For uniform access, the performance of a splay tree will be considerably worse than a somewhat balanced simple binary search tree. For uniform access, unlike splay trees, these other data structures provide worst-case time guarantess and can be more efficient to use.

\filbreak
\vskip 1cm
{\bf Points to Rememeber}

\vskip 3mm
\qquad$\bullet$ A binary search tree, also known as an ordered binary tree, is a variant of binary tree in which all the nodes in the left sub-tree have a value less than that of the root and all the nodes in the right sub-tree have a value either equal to or greater than the root node.

\vskip 3mm
\qquad$\bullet$ The average running time of a search operation is $O(\log_2 n)$. However, in the worst case, a binary search tree will take $O(n)$ time to search an element from the tree.

\vskip 3mm
\qquad$\bullet$ Mirror image of a binary search tree is obtained by interchanging the left sub-tree with the right sub-tree at every node of the tree.

\vskip 3mm
\qquad$\bullet$ In a threaded binary tree, null entries can be replaced to store a pointer to either the in-order predecessor or in-order successor of a node.

\vskip 3mm
\qquad$\bullet$ A one-way threaded tree is also called a single threaded tree. In a two-way threaded tree, also called a double threaded tree, threads will appear in both the left and the right field of the node.

\vskip 3mm
\qquad$\bullet$ An AVL tree is a self-balancing tree which is also known as a height-balanced tree. Each node has a balance factor associated with it, which is calculated by subtracting the height of the right sub-tree from the height of the left sub-tree. In a height balanced tree, every node has a balance factor of either $0, 1,$ or $-1$.

\vskip 3mm
\qquad$\bullet$ A red-black tree is a self-balacing binary search tree which is also called as a 'symmetric binary B-tree'. Although a red-black tree is complex, it has good worst case running time for its operations and is efficient to use, as searching, insertion, and deletion can all be done int $O(\log n)$ time.

\vskip 3mm
\qquad$\bullet$ A splay tree is a self-balancing binary search tree with an additional property that recently accessed elements can be re-accessed fast.

%$$\vbox{\+\bf \cleartabs& \cr
%	\+\cr
%	\+\cr
%	\+\cr}$$

\vfill\eject
\bye
